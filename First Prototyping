/*
  ╔══════════════════════════════════════════════════════════╗
  ║              StudyMate  Firmware  v4.0                   ║
  ║     ESP32 + I2C 20x4 LCD + DS3231 OR ESP32 Hotspot       ║
  ╠══════════════════════════════════════════════════════════╣
  ║  WIRING                                                  ║
  ║  LCD  SDA -> GPIO 4    SCL -> GPIO 16                    ║
  ║  RTC  SDA -> GPIO 4    SCL -> GPIO 16  (optional)        ║
  ║  BTN_A -> GPIO 27   (SELECT / PAUSE)                     ║
  ║  BTN_B -> GPIO 26   (BACK  / LONG=QUIT)                  ║
  ╠══════════════════════════════════════════════════════════╣
  ║  HOW TO SYNC TIME                                        ║
  ║  1. Power on device                                      ║
  ║  2. LCD shows "Connect to WiFi: StudyMate-Setup"         ║
  ║  3. Phone -> Settings -> WiFi -> StudyMate-Setup         ║
  ║     (no password needed)                                 ║
  ║  4. Open phone browser -> go to  192.168.4.1             ║
  ║  5. Your phone time is pre-filled. Tap "Sync Time"       ║
  ║  6. Done! Hotspot closes, clock starts.                  ║
  ╠══════════════════════════════════════════════════════════╣
  ║  LIBRARIES (Arduino Library Manager)                     ║
  ║  - LiquidCrystal I2C  by Frank de Brabander              ║
  ║  - RTClib              by Adafruit                       ║
  ║  WiFi + WebServer are built into ESP32 Arduino core      ║
  ╚══════════════════════════════════════════════════════════╝
*/

// ── Includes ────────────────────────────────────────────────
#include <time.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <RTClib.h>
#include <WiFi.h>
#include <WebServer.h>

// ── Hotspot config ──────────────────────────────────────────
#define AP_SSID  "StudyMate-Setup"
// Leave AP_PASS empty for an open (no password) network
#define AP_PASS  ""

// ── Pin definitions ─────────────────────────────────────────
#define BTN_A 27
#define BTN_B 26

// ── Global objects ──────────────────────────────────────────
LiquidCrystal_I2C lcd(0x27, 20, 4);
RTC_DS3231        rtc;
WebServer         server(80);

// ════════════════════════════════════════════════════════════
//  TIME SOURCE
// ════════════════════════════════════════════════════════════
enum TimeSource { TS_NONE, TS_RTC, TS_SOFTWARE };
TimeSource timeSource = TS_NONE;

// Software clock — updated after phone sync
time_t   swEpoch  = 0;
uint32_t swMillis = 0;

// Returns current UTC epoch seconds
time_t nowEpoch() {
  if (timeSource == TS_RTC) {
    return (time_t)rtc.now().unixtime();
  }
  return swEpoch + (time_t)((millis() - swMillis) / 1000UL);
}

// Decoded time fields (global, filled by decodeEpoch)
uint16_t ct_year;
uint8_t  ct_month, ct_day, ct_hour, ct_minute, ct_second, ct_dow;

void decodeEpoch(time_t ep) {
  struct tm t;
  gmtime_r(&ep, &t);
  ct_year   = (uint16_t)(t.tm_year + 1900);
  ct_month  = (uint8_t)(t.tm_mon  + 1);
  ct_day    = (uint8_t)t.tm_mday;
  ct_hour   = (uint8_t)t.tm_hour;
  ct_minute = (uint8_t)t.tm_min;
  ct_second = (uint8_t)t.tm_sec;
  ct_dow    = (uint8_t)t.tm_wday;  // 0 = Sunday
}

// ════════════════════════════════════════════════════════════
//  APP STATES
// ════════════════════════════════════════════════════════════
enum AppState {
  STATE_SPLASH,
  STATE_TIME_SYNC_AP,
  STATE_HOME_CLOCK,
  STATE_MAIN_MENU,
  STATE_SESSION_SELECT,
  STATE_STUDY_RUNNING,
  STATE_EXERCISE_RUNNING,
  STATE_DONE
};
AppState appState = STATE_SPLASH;

// ── Timing ──────────────────────────────────────────────────
unsigned long splashStart     = 0;
unsigned long lastClockUpdate = 0;
bool          timeSynced      = false;

// ── Menu state ──────────────────────────────────────────────
int menuCursor    = 0;
int sessionCursor = 0;
const int sessionOptions[] = {10, 30, 60};

// ── Study timer ─────────────────────────────────────────────
long          studyTotalSeconds = 0;
bool          studyRunning      = false;
bool          studyPaused       = false;
unsigned long studyPrevMillis   = 0;

// ── Exercise data ────────────────────────────────────────────
struct ExerciseMove {
  int atSecond;
  const char* name;
};

const ExerciseMove exercises[] = {
  {0,   "Get Ready!        "},
  {27,  "Jack Squats       "},
  {57,  "Push-Ups          "},
  {87,  "Caterpillars      "},
  {117, "Inch Worms        "},
  {147, "Elbow Plank       "},
  {177, "Cat Stretch       "},
  {207, "Wats Up Dawg      "},
  {237, "Heel Tap Crunch   "},
  {267, "Hip Thrust        "},
  {297, "Squat Pulse+Calf  "},
  {357, "Eagle Walks       "},
  {387, "Upright Plank     "},
  {417, "Hamstrng Stretch  "},
  {477, "Superman Strokes  "},
  {507, "Negative Push-Ups "},
  {537, "Hip Stretch Lunge "},
  {567, "Squat Taps        "},
  {597, "Jumping Jacks     "}
};
const int NUM_EXERCISES  = sizeof(exercises) / sizeof(exercises[0]);
const int EXERCISE_TOTAL = 600;

long          exerciseElapsed     = 0;
bool          exerciseRunning     = false;
bool          exercisePaused      = false;
unsigned long exercisePrevMillis  = 0;
bool          doneIsExercise      = false;

// ════════════════════════════════════════════════════════════
//  BUTTONS
// ════════════════════════════════════════════════════════════
unsigned long btnA_pt   = 0, btnB_pt   = 0;
bool          btnA_held = false, btnB_held = false;
bool          btnA_proc = false, btnB_proc = false;

const unsigned long LONG_PRESS = 700;
const unsigned long DEBOUNCE   = 50;

void handleBtn(int pin,
               unsigned long &pt, bool &held, bool &proc,
               bool &sOut, bool &lOut) {
  sOut = false;
  lOut = false;
  if (digitalRead(pin) == LOW) {
    if (!held) {
      held = true;
      proc = false;
      pt   = millis();
    } else if (!proc && (millis() - pt >= LONG_PRESS)) {
      lOut = true;
      proc = true;
    }
  } else {
    if (held) {
      if (!proc && (millis() - pt >= DEBOUNCE)) sOut = true;
      held = false;
      proc = false;
    }
  }
}

// ════════════════════════════════════════════════════════════
//  LCD HELPERS
// ════════════════════════════════════════════════════════════
void printCenter(int row, const char* txt) {
  int len = (int)strlen(txt);
  int col = (20 - len) / 2;
  if (col < 0) col = 0;
  lcd.setCursor(col, row);
  lcd.print(txt);
}

void pad2(int v) {
  if (v < 10) lcd.print("0");
  lcd.print(v);
}

void printCountdown(int row, int col, long secs) {
  lcd.setCursor(col, row);
  pad2((int)(secs / 60));
  lcd.print(":");
  pad2((int)(secs % 60));
}

// ── Time formatting ─────────────────────────────────────────
const char* DOW_N[] = {"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};
const char* MON_N[] = {"","Jan","Feb","Mar","Apr","May","Jun",
                        "Jul","Aug","Sep","Oct","Nov","Dec"};

uint8_t to12h(uint8_t h) {
  if (h == 0)  return 12;
  if (h > 12)  return h - 12;
  return h;
}

const char* ampmStr(uint8_t h) {
  return (h < 12) ? "AM" : "PM";
}

// ════════════════════════════════════════════════════════════
//  WEB PAGE  (served from ESP32 hotspot)
// ════════════════════════════════════════════════════════════
const char HTML_PAGE[] PROGMEM = R"rawhtml(
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>StudyMate Time Sync</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:'Segoe UI',sans-serif;background:#0f0f0f;color:#f0f0f0;
       display:flex;flex-direction:column;align-items:center;
       justify-content:center;min-height:100vh;padding:20px}
  .card{background:#1a1a1a;border:1px solid #2a2a2a;border-radius:16px;
        padding:32px 28px;width:100%;max-width:380px;
        box-shadow:0 8px 32px rgba(0,0,0,.5)}
  h1{font-size:1.5rem;font-weight:700;margin-bottom:4px}
  .sub{font-size:.85rem;color:#888;margin-bottom:24px}
  .preview{background:#111;border-radius:10px;padding:16px;
           margin-bottom:22px;text-align:center}
  .preview .time{font-size:2.2rem;font-weight:700;color:#4f8fff;letter-spacing:.05em}
  .preview .date{font-size:.9rem;color:#888;margin-top:4px}
  label{display:block;font-size:.78rem;color:#aaa;margin-bottom:5px;
        text-transform:uppercase;letter-spacing:.05em}
  input{width:100%;background:#111;border:1px solid #333;border-radius:8px;
        color:#fff;font-size:1rem;padding:10px 14px;margin-bottom:18px;outline:none}
  input:focus{border-color:#4f8fff}
  button{width:100%;background:#4f8fff;border:none;border-radius:10px;
         color:#fff;font-size:1.05rem;font-weight:600;padding:14px;cursor:pointer}
  button:active{background:#3a72e0}
  .ok{display:none;margin-top:16px;background:#0d2e0d;border:1px solid #2d6a2d;
      border-radius:10px;padding:14px;text-align:center;color:#5de85d;font-weight:600}
</style>
</head>
<body>
<div class="card">
  <h1>&#128337; StudyMate</h1>
  <p class="sub">Sync your phone's time to the device</p>

  <div class="preview">
    <div class="time" id="liveTime">--:-- --</div>
    <div class="date" id="liveDate">Loading...</div>
  </div>

  <label>Date</label>
  <input type="date" id="dateInput">

  <label>Time</label>
  <input type="time" id="timeInput" step="1">

  <button onclick="syncTime()">&#9654;&nbsp; Sync Time to Device</button>
  <div class="ok" id="okMsg">&#10003; Synced! You can close this page.</div>
</div>

<script>
var days   = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

function pad(n){ return String(n).padStart(2,'0'); }

function fillNow(){
  var d = new Date();
  document.getElementById('dateInput').value =
    d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate());
  document.getElementById('timeInput').value =
    pad(d.getHours())+':'+pad(d.getMinutes())+':'+pad(d.getSeconds());
}

function updatePreview(){
  var d  = new Date();
  var h  = d.getHours(), m = d.getMinutes(), s = d.getSeconds();
  var ap = h < 12 ? 'AM' : 'PM';
  var h12 = h % 12 || 12;
  document.getElementById('liveTime').textContent =
    pad(h12)+':'+pad(m)+':'+pad(s)+' '+ap;
  document.getElementById('liveDate').textContent =
    days[d.getDay()]+', '+d.getDate()+' '+months[d.getMonth()]+' '+d.getFullYear();
}

fillNow();
setInterval(updatePreview, 1000);
updatePreview();

function syncTime(){
  var dv = document.getElementById('dateInput').value;
  var tv = document.getElementById('timeInput').value;
  if(!dv || !tv){ alert('Please fill in date and time.'); return; }
  var dp = dv.split('-'), tp = tv.split(':');
  var dt = new Date(dp[0], dp[1]-1, dp[2], tp[0], tp[1], tp[2]||0);
  var epoch = Math.floor(dt.getTime() / 1000);
  fetch('/settime?epoch='+epoch)
    .then(function(r){ return r.text(); })
    .then(function(){
      document.getElementById('okMsg').style.display = 'block';
      document.querySelector('button').disabled = true;
    })
    .catch(function(){ alert('Connection error. Are you on StudyMate-Setup WiFi?'); });
}
</script>
</body>
</html>
)rawhtml";

// ════════════════════════════════════════════════════════════
//  WEB SERVER HANDLERS
// ════════════════════════════════════════════════════════════
void handleRoot() {
  server.send_P(200, "text/html", HTML_PAGE);
}

void handleSetTime() {
  if (!server.hasArg("epoch")) {
    server.send(400, "text/plain", "Missing epoch");
    return;
  }

  time_t epoch = (time_t)server.arg("epoch").toInt();

  // Write to DS3231 if available
  if (timeSource == TS_RTC || rtc.begin()) {
    rtc.adjust(DateTime((uint32_t)epoch));
    timeSource = TS_RTC;
  }

  // Always update software clock
  swEpoch  = epoch;
  swMillis = millis();
  if (timeSource == TS_NONE) timeSource = TS_SOFTWARE;

  timeSynced = true;
  server.send(200, "text/plain", "OK");
}

void handleNotFound() {
  // Redirect any unknown URL back to main page (helps captive portal)
  server.sendHeader("Location", "http://192.168.4.1", true);
  server.send(302, "text/plain", "");
}

// ════════════════════════════════════════════════════════════
//  HOTSPOT START / STOP
// ════════════════════════════════════════════════════════════
void startHotspot() {
  WiFi.mode(WIFI_AP);

  if (strlen(AP_PASS) > 0) {
    WiFi.softAP(AP_SSID, AP_PASS);
  } else {
    WiFi.softAP(AP_SSID);
  }

  IPAddress ip(192, 168, 4, 1);
  IPAddress gw(192, 168, 4, 1);
  IPAddress sn(255, 255, 255, 0);
  WiFi.softAPConfig(ip, gw, sn);

  server.on("/",         handleRoot);
  server.on("/settime",  handleSetTime);
  server.onNotFound(     handleNotFound);
  server.begin();
}

void stopHotspot() {
  server.stop();
  WiFi.softAPdisconnect(true);
  WiFi.mode(WIFI_OFF);
}

// ════════════════════════════════════════════════════════════
//  SCREEN DRAWS
// ════════════════════════════════════════════════════════════

void drawSplash() {
  lcd.clear();
  printCenter(1, "StudyMate");
  printCenter(2, "Your Focus Partner");
}

/*  Waiting for phone sync
    --------------------
    Connect to WiFi:
    StudyMate-Setup
    Open browser:
    192.168.4.1
*/
void drawTimeSyncAP() {
  lcd.clear();
  printCenter(0, "Connect to WiFi:");
  printCenter(1, AP_SSID);
  printCenter(2, "Open browser:");
  printCenter(3, "192.168.4.1");
}

void drawSyncDone() {
  lcd.clear();
  printCenter(0, "Time Synced!");
  printCenter(1, "Let's go!");
  printCenter(2, "Starting clock...");
}

/*  Home clock
    --------------------
    Wed, 14 May 2025
         10:45 AM
              :33
    [A] Menu   src:RTC
*/
void drawHomeClock() {
  decodeEpoch(nowEpoch());
  lcd.clear();

  // Row 0: date
  char line0[21];
  snprintf(line0, 21, "%s, %02d %s %04d",
           DOW_N[ct_dow], ct_day, MON_N[ct_month], ct_year);
  printCenter(0, line0);

  // Row 1: time
  char line1[21];
  snprintf(line1, 21, "     %02d:%02d %s     ",
           to12h(ct_hour), ct_minute, ampmStr(ct_hour));
  lcd.setCursor(0, 1);
  lcd.print(line1);

  // Row 2: seconds
  char line2[21];
  snprintf(line2, 21, "          :%02d      ", ct_second);
  lcd.setCursor(0, 2);
  lcd.print(line2);

  // Row 3: hint + source badge
  lcd.setCursor(0, 3);
  lcd.print("[A] Menu");
  lcd.setCursor(12, 3);
  lcd.print("src:");
  if      (timeSource == TS_RTC)      lcd.print("RTC");
  else if (timeSource == TS_SOFTWARE) lcd.print("WiF");
  else                                lcd.print("---");
}

void drawMainMenu() {
  lcd.clear();
  printCenter(0, "-- StudyMate --");
  lcd.setCursor(0, 1);
  lcd.print(menuCursor == 0 ? "> " : "  ");
  lcd.print("Study Session");
  lcd.setCursor(0, 2);
  lcd.print(menuCursor == 1 ? "> " : "  ");
  lcd.print("Exercise Mode");
  lcd.setCursor(0, 3);
  lcd.print("  A:move  B:select  ");
}

void drawSessionSelect() {
  lcd.clear();
  printCenter(0, "Choose Duration:");
  const char* labels[] = {"10 minutes", "30 minutes", "60 minutes"};
  for (int i = 0; i < 3; i++) {
    lcd.setCursor(0, i + 1);
    lcd.print(sessionCursor == i ? "> " : "  ");
    lcd.print(labels[i]);
  }
}

void drawStudyRunning() {
  long total     = sessionOptions[sessionCursor] * 60L;
  long remaining = studyTotalSeconds;
  int  bars      = (int)(((total - remaining) * 16L) / total);

  lcd.clear();
  printCenter(0, "Study Session");

  lcd.setCursor(0, 1);
  lcd.print("  Time Left: ");
  printCountdown(1, 13, remaining);

  lcd.setCursor(2, 2);
  lcd.print("[");
  for (int i = 0; i < 16; i++) lcd.print(i < bars ? '#' : '-');
  lcd.print("]");

  lcd.setCursor(0, 3);
  lcd.print(studyPaused ? "A:resume  Blong:bk" : "A:pause   Blong:bk");
}

void drawExerciseRunning() {
  // Find current exercise
  int idx = 0;
  for (int i = 0; i < NUM_EXERCISES; i++) {
    if (exerciseElapsed >= exercises[i].atSecond) idx = i;
    else break;
  }

  lcd.clear();
  printCenter(0, "Exercise Mode");
  lcd.setCursor(2, 1);
  lcd.print(exercises[idx].name);
  lcd.setCursor(0, 2);
  lcd.print("  Time Left: ");
  printCountdown(2, 13, EXERCISE_TOTAL - exerciseElapsed);
  lcd.setCursor(0, 3);
  lcd.print(exercisePaused ? "A:resume  Blong:bk" : "A:pause   Blong:bk");
}

void drawDone() {
  lcd.clear();
  printCenter(0, doneIsExercise ? "Exercise Done!" : "Session Done!");
  printCenter(1, "Amazing Work!");
  printCenter(3, "  Any btn: home    ");
}

// ════════════════════════════════════════════════════════════
//  STATE TRANSITIONS
// ════════════════════════════════════════════════════════════
void goToHome() {
  appState        = STATE_HOME_CLOCK;
  lastClockUpdate = 0;
  drawHomeClock();
}

void goToMainMenu() {
  appState   = STATE_MAIN_MENU;
  menuCursor = 0;
  drawMainMenu();
}

void startStudy() {
  studyTotalSeconds = sessionOptions[sessionCursor] * 60L;
  studyRunning      = true;
  studyPaused       = false;
  studyPrevMillis   = millis();
  appState          = STATE_STUDY_RUNNING;
  drawStudyRunning();
}

void startExercise() {
  exerciseElapsed    = 0;
  exerciseRunning    = true;
  exercisePaused     = false;
  exercisePrevMillis = millis();
  appState           = STATE_EXERCISE_RUNNING;
  drawExerciseRunning();
}

// ════════════════════════════════════════════════════════════
//  SETUP
// ════════════════════════════════════════════════════════════
void setup() {
  Serial.begin(115200);
  Wire.begin(4, 16);   // SDA = GPIO 4, SCL = GPIO 16

  pinMode(BTN_A, INPUT_PULLUP);
  pinMode(BTN_B, INPUT_PULLUP);

  lcd.init();
  lcd.backlight();

  // Splash
  drawSplash();
  delay(3000);

  // Try DS3231 with valid time first
  if (rtc.begin() && !rtc.lostPower()) {
    timeSource = TS_RTC;
    Serial.println("DS3231 found. Using RTC time.");
    goToHome();
    return;
  }

  // No RTC or RTC has no time — start hotspot
  Serial.println("No valid RTC. Starting hotspot for time sync.");
  startHotspot();
  appState = STATE_TIME_SYNC_AP;
  drawTimeSyncAP();
}

// ════════════════════════════════════════════════════════════
//  LOOP
// ════════════════════════════════════════════════════════════
void loop() {
  bool aShort, aLong, bShort, bLong;
  handleBtn(BTN_A, btnA_pt, btnA_held, btnA_proc, aShort, aLong);
  handleBtn(BTN_B, btnB_pt, btnB_held, btnB_proc, bShort, bLong);

  switch (appState) {

    // ── WAITING FOR PHONE SYNC ────────────────────────────
    case STATE_TIME_SYNC_AP:
      server.handleClient();

      if (timeSynced) {
        stopHotspot();
        drawSyncDone();
        delay(2000);
        goToHome();
      }

      // Long press B = skip sync and go straight to clock (shows 00:00)
      if (bLong) {
        stopHotspot();
        swEpoch    = 0;
        swMillis   = millis();
        timeSource = TS_SOFTWARE;
        goToHome();
      }
      break;

    // ── HOME CLOCK ────────────────────────────────────────
    case STATE_HOME_CLOCK: {
      unsigned long now = millis();
      if (now - lastClockUpdate >= 1000) {
        lastClockUpdate = now;
        drawHomeClock();
      }
      if (aShort) goToMainMenu();
      break;
    }

    // ── MAIN MENU ─────────────────────────────────────────
    case STATE_MAIN_MENU:
      if (aShort) {
        menuCursor = (menuCursor + 1) % 2;
        drawMainMenu();
      }
      if (bShort) {
        if (menuCursor == 0) {
          sessionCursor = 0;
          appState      = STATE_SESSION_SELECT;
          drawSessionSelect();
        } else {
          startExercise();
        }
      }
      if (bLong) goToHome();
      break;

    // ── SESSION SELECT ────────────────────────────────────
    case STATE_SESSION_SELECT:
      if (aShort) {
        sessionCursor = (sessionCursor + 1) % 3;
        drawSessionSelect();
      }
      if (bShort) startStudy();
      if (bLong)  goToMainMenu();
      break;

    // ── STUDY RUNNING ─────────────────────────────────────
    case STATE_STUDY_RUNNING:
      if (aShort) {
        studyPaused = !studyPaused;
        if (!studyPaused) studyPrevMillis = millis();
        drawStudyRunning();
      }
      if (bLong) {
        studyRunning = false;
        studyPaused  = false;
        goToHome();
      }
      if (studyRunning && !studyPaused) {
        unsigned long now = millis();
        if (now - studyPrevMillis >= 1000) {
          studyPrevMillis = now;
          if (studyTotalSeconds > 0) {
            studyTotalSeconds--;
            drawStudyRunning();
          } else {
            studyRunning   = false;
            doneIsExercise = false;
            appState       = STATE_DONE;
            drawDone();
          }
        }
      }
      break;

    // ── EXERCISE RUNNING ──────────────────────────────────
    case STATE_EXERCISE_RUNNING:
      if (aShort) {
        exercisePaused = !exercisePaused;
        if (!exercisePaused) exercisePrevMillis = millis();
        drawExerciseRunning();
      }
      if (bLong) {
        exerciseRunning = false;
        exercisePaused  = false;
        goToHome();
      }
      if (exerciseRunning && !exercisePaused) {
        unsigned long now = millis();
        if (now - exercisePrevMillis >= 1000) {
          exercisePrevMillis = now;
          if (exerciseElapsed < EXERCISE_TOTAL) {
            exerciseElapsed++;
            drawExerciseRunning();
          } else {
            exerciseRunning = false;
            doneIsExercise  = true;
            appState        = STATE_DONE;
            drawDone();
          }
        }
      }
      break;

    // ── DONE ──────────────────────────────────────────────
    case STATE_DONE:
      if (aShort || bShort || aLong || bLong) goToHome();
      break;

    default:
      break;
  }
}
